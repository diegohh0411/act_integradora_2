<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Python Code Syntax Highlighter</title>
    <style>
        body { font-family: 'Courier New', monospace; background-color: #f5f5f5; margin: 20px; }
        .code-container { background-color: white; padding: 20px; border-radius: 8px; box-shadow: 0 2px 10px rgba(0,0,0,0.1); }
        .keyword { color: #000fff; font-weight: bold; }
        .number { color: #008000; font-weight: bold; }
        .string { color: #ff0000; }
        .comment { color: #808080; font-style: italic; }
        .identifier { color: #000080; }
        .operator { color: #ff8000; font-weight: bold; }
        pre { white-space: pre-wrap; word-wrap: break-word; line-height: 1.4; }
        h2 { color: #333; border-bottom: 2px solid #eee; padding-bottom: 10px; }
    </style>
</head>
<body>
    <div class="code-container">
        <h2>Python Code with DFA-based Syntax Highlighting</h2>
        <pre><span class="comment"># Este archivo contiene ejemplos de todas las clases léxicas de Python</span>
"""
Comentario de múltiples líneas
que demuestra las docstrings
"""

<span class="comment"># Importaciones con diferentes variantes</span>
<span class="keyword">import</span> math
<span class="keyword">import</span> os <span class="keyword">as</span> sistema
<span class="keyword">from</span> collections <span class="keyword">import</span> defaultdict, Counter
<span class="keyword">from</span> typing <span class="keyword">import</span> List, Dict, Optional, Union

<span class="comment"># Keywords: def, class, if, elif, else, for, while, try, except, finally, with, as, import, from, return, yield, break, continue, pass, global, nonlocal, lambda, and, or, not, in, is, True, False, None</span>

<span class="comment"># Definición de clase con herencia</span>
<span class="keyword">class</span> MiClase(object):
    """Docstring de la clase"""
    
    <span class="comment"># Variable de clase</span>
    variable_clase = "valor_clase"
    
    <span class="keyword">def</span> __init__(self, parametro: int = 0):
        <span class="comment"># Operador de asignación</span>
        self.atributo = parametro
        self._atributo_privado = <span class="keyword">None</span>
        self.__atributo_muy_privado = "secreto"
    
    <span class="keyword">def</span> metodo_ejemplo(self, x: float, y: float) -> float:
        """Método que demuestra operadores aritméticos"""
        <span class="comment"># Operadores aritméticos: +, -, *, /, //, %, **</span>
        suma = x + y
        resta = x - y
        multiplicacion = x * y
        division = x / y
        division_entera = x // y
        modulo = x % y
        potencia = x ** y
        
        <span class="comment"># Operadores de asignación compuesta: +=, -=, *=, /=, //=, %=, **=</span>
        suma += 10
        resta -= 5
        multiplicacion *= 2
        division /= 3
        
        <span class="keyword">return</span> suma

<span class="comment"># Función con diferentes tipos de parámetros</span>
<span class="keyword">def</span> funcion_compleja(*args, **kwargs):
    """Función con argumentos variables"""
    <span class="comment"># Operadores de comparación: ==, !=, <, >, <=, >=, is, is not, in, not in</span>
    <span class="keyword">if</span> len(args) > 0 <span class="keyword">and</span> args[0] <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">None</span>:
        print(f"Primer argumento: {args[0]}")
    
    <span class="comment"># Operadores lógicos: and, or, not</span>
    <span class="keyword">if</span> args <span class="keyword">and</span> kwargs <span class="keyword">and</span> <span class="keyword">not</span> (len(args) == 0 <span class="keyword">or</span> len(kwargs) == 0):
        print("Tenemos argumentos")
    
    <span class="comment"># Operadores de membresía: in, not in</span>
    <span class="keyword">if</span> 'clave' <span class="keyword">in</span> kwargs:
        print("Clave encontrada")
    
    <span class="comment"># Operadores de identidad: is, is not</span>
    <span class="keyword">if</span> args[0] <span class="keyword">is</span> <span class="keyword">True</span>:
        print("Es verdadero")

<span class="comment"># Función lambda</span>
lambda_func = <span class="keyword">lambda</span> x, y: x + y <span class="keyword">if</span> x > 0 <span class="keyword">else</span> y

<span class="comment"># Diferentes tipos de datos</span>
<span class="comment"># Enteros (decimales, hexadecimales, octales, binarios)</span>
entero_decimal = 42
entero_hex = 0xFF
entero_octal = 0o777
entero_binario = 0b1010

<span class="comment"># Flotantes</span>
flotante = 3.14159
flotante_cientifico = 1.5e-10
flotante_negativo = -2.718

<span class="comment"># Números complejos</span>
complejo = 3 + 4j

<span class="comment"># Strings con diferentes tipos de comillas</span>
string_simple = 'cadena simple'
string_doble = "cadena doble"
string_triple = '''cadena
de múltiples
líneas'''
string_raw = r"cadena raw con \n caracteres especiales"
string_formatted = f"String formateado: {entero_decimal}"
string_unicode = "cadena con unicode: ñáéíóú"

<span class="comment"># Listas con diferentes elementos</span>
lista = [1, 2, 3, "texto", <span class="keyword">True</span>, <span class="keyword">None</span>, [1, 2]]
lista_comprension = [x**2 <span class="keyword">for</span> x <span class="keyword">in</span> range(10) <span class="keyword">if</span> x % 2 == 0]

<span class="comment"># Tuplas</span>
tupla = (1, 2, 3)
tupla_un_elemento = (42,)

<span class="comment"># Diccionarios</span>
diccionario = {
    "clave1": "valor1",
    "clave2": 42,
    'clave3': [1, 2, 3],
    42: "clave numérica"
}
dict_comprension = {k: v**2 <span class="keyword">for</span> k, v <span class="keyword">in</span> enumerate(range(5))}

<span class="comment"># Conjuntos</span>
conjunto = {1, 2, 3, 4, 5}
conjunto_vacio = set()

# Operadores bit a bit: &, |, ^, ~, <<, >>
resultado_and = 5 & 3
resultado_or = 5 | 3
resultado_xor = 5 ^ 3
resultado_not = ~5
desplazamiento_izq = 5 << 2
desplazamiento_der = 20 >> 2

<span class="comment"># Estructura de control: if-elif-else</span>
<span class="keyword">def</span> control_flujo(valor):
    <span class="keyword">if</span> valor > 10:
        print("Mayor que 10")
    <span class="keyword">elif</span> valor > 5:
        print("Entre 5 y 10")
    <span class="keyword">else</span>:
        print("Menor o igual a 5")

<span class="comment"># Bucles: for y while</span>
<span class="keyword">def</span> bucles_ejemplo():
    <span class="comment"># Bucle for</span>
    <span class="keyword">for</span> i <span class="keyword">in</span> range(10):
        <span class="keyword">if</span> i == 5:
            <span class="keyword">continue</span>  <span class="comment"># Salta a la siguiente iteración</span>
        <span class="keyword">if</span> i == 8:
            <span class="keyword">break</span>     <span class="comment"># Sale del bucle</span>
        print(i)
    
    <span class="comment"># Bucle while</span>
    contador = 0
    <span class="keyword">while</span> contador < 5:
        print(f"Contador: {contador}")
        contador += 1

<span class="comment"># Manejo de excepciones: try-except-finally</span>
<span class="keyword">def</span> manejo_excepciones():
    <span class="keyword">try</span>:
        resultado = 10 / 0
    <span class="keyword">except</span> ZeroDivisionError <span class="keyword">as</span> e:
        print(f"Error: {e}")
    <span class="keyword">except</span> Exception <span class="keyword">as</span> e:
        print(f"Error general: {e}")
    <span class="keyword">else</span>:
        print("No hubo errores")
    <span class="keyword">finally</span>:
        print("Siempre se ejecuta")

<span class="comment"># Context manager: with</span>
<span class="keyword">def</span> context_manager_ejemplo():
    <span class="keyword">with</span> open("archivo.txt", "w") <span class="keyword">as</span> archivo:
        archivo.write("Contenido <span class="keyword">del</span> archivo")

<span class="comment"># Generadores y yield</span>
<span class="keyword">def</span> generador():
    <span class="keyword">for</span> i <span class="keyword">in</span> range(5):
        <span class="keyword">yield</span> i**2

<span class="comment"># Decoradores</span>
<span class="keyword">def</span> decorador(func):
    <span class="keyword">def</span> wrapper(*args, **kwargs):
        print("Antes de la función")
        resultado = func(*args, **kwargs)
        print("Después de la función")
        <span class="keyword">return</span> resultado
    <span class="keyword">return</span> wrapper

@decorador
<span class="keyword">def</span> funcion_decorada():
    print("Función decorada")

<span class="comment"># Variables globales y nonlocal</span>
variable_global = "<span class="keyword">global</span>"

<span class="keyword">def</span> funcion_externa():
    variable_local = "local"
    
    <span class="keyword">def</span> funcion_interna():
        <span class="keyword">nonlocal</span> variable_local
        <span class="keyword">global</span> variable_global
        variable_local = "modificada"
        variable_global = "modificada globalmente"
    
    funcion_interna()
    <span class="keyword">return</span> variable_local

<span class="comment"># Expresiones regulares y caracteres especiales</span>
patron_regex = r"[a-zA-Z0-9]+@[a-zA-Z0-9]+\.[a-zA-Z]{2,}"

<span class="comment"># Función principal</span>
<span class="keyword">def</span> <span class="keyword">main</span>():
    """Función principal que demuestra el uso de todas las clases léxicas"""
    print("=== Demostración de clases léxicas ===")
    
    <span class="comment"># Instanciar clase</span>
    objeto = MiClase(100)
    resultado = objeto.metodo_ejemplo(10.5, 5.2)
    
    <span class="comment"># Llamar funciones</span>
    funcion_compleja(1, 2, 3, clave="valor", otra_clave=42)
    control_flujo(15)
    bucles_ejemplo()
    manejo_excepciones()
    
    <span class="comment"># Usar generador</span>
    gen = generador()
    <span class="keyword">for</span> valor <span class="keyword">in</span> gen:
        print(f"Valor generado: {valor}")
    
    <span class="comment"># Función decorada</span>
    funcion_decorada()
    
    <span class="comment"># Función externa</span>
    resultado_local = funcion_externa()
    print(f"Resultado local: {resultado_local}")
    
    <span class="comment"># Operador ternario</span>
    resultado_ternario = "positivo" <span class="keyword">if</span> resultado > 0 <span class="keyword">else</span> "negativo"
    print(f"Resultado ternario: {resultado_ternario}")
    
    <span class="comment"># Función lambda</span>
    resultado_lambda = lambda_func(5, 3)
    print(f"Resultado <span class="keyword">lambda</span>: {resultado_lambda}")
    
    <span class="comment"># Unpacking</span>
    a, b, *resto = [1, 2, 3, 4, 5]
    print(f"a={a}, b={b}, resto={resto}")
    
    <span class="comment"># Walrus operator (Python 3.8+)</span>
    <span class="keyword">if</span> (n := len(lista)) > 5:
        print(f"Lista tiene {n} elementos")
    
    <span class="keyword">return</span> 0

<span class="comment"># Ejecutar si es el archivo principal</span>
<span class="keyword">if</span> __name__ == "__main__":
    <span class="comment"># Comentario de línea final</span>
    exit_code = <span class="keyword">main</span>()  <span class="comment"># Llamada a función principal</span>
    exit(exit_code)     <span class="comment"># Salida del programa</span></pre>
    </div>
</body>
</html>